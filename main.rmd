---
title: 'STAT 428: Final Project'
author: "Akshay Mahesh (mahesh4), Max Su (maxsu2), Adam Zhang(ajzhang2), Nicholas Costello (nicoste2), Kasi Manikumar (manikum2)"
date: "Due Week 14 Saturday, December 1 by 11.59 PM on Compass"
output:
  html_document:
    theme: readable
    toc: yes
  pdf_document:
    toc: yes
---

# Abstract

TODO

# Introduction

Kruskal's Count is a mathematical magic card trick that we will optimize for the highest chances of success given two parameters: the royal card count value (Jack, Queen, King) and the number the magician should pick for the best chance of success of performing this trick with a non-robotic victim .

## Card Trick

Instructions for the victim: The victim shuffles a deck thoroughly, then secretly picks a number between 1 and 10. The cards are dealt out slowly and steadily, face up, the victim's first key card being the one at the position they choose in advance. The value of this card determines how many to deal out to the next key card, e.g., if the key card is a 4 victim counts off four cards, the last being the new key card. Royal cards count as 5. The process is repeated as often as is possible.

Eventually they will get a *key card* (perhaps the last card in the deck) which is not followed by enough cards to get to another one; this last key card is the one they remember. No matter how steadily the victim deals, with no pauses to give any hints as to which cards are key cards, you successfully identify their last key card. For many people, this trick grows more mysterious with repetition.

Magician's method: The magician mirrors the same instructions as the victim, also picking some random card among the first ten until arriving at the last key card. There's a very high probability that both the magician and the victim come to the same final key card because when the magician and the victim both come to the same card at any point in time, they will also arrive at the last key card.




```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
options(scipen = 1, digits = 4, width = 80)
library(hashmap)
```


```{r,eval=TRUE, echo=TRUE, include=TRUE}
human_distribution <- function(n){
  setwd('.')
  data = as.vector(read.csv(file="data.csv",check.names=FALSE, header=FALSE))

  estimators = numeric(10)
  for(i in 1:10){
    estimators[i] = sum(data <= i) / length(data)
  }
  estimators = c(0, estimators)

  sample = c()
  for(i in 1:n){
    x = runif(n = 1, min = 0, max = 1)
    sample = c(sum(estimators < x),sample)
  }
  return(sample)
}
```

```{r,eval=TRUE, echo=TRUE, include=TRUE}
ranks <- c("A",2:10,"J","Q","K")
cards = paste(rep(ranks, 4), c("H","D","S","C"))

# Create a randomized deck of cards.
create_shuffled_deck <- function() {
  sample(cards, 52)
}

# Create a rank value hashmap.
create_rank_value_map <- function(jack_value, queen_value, king_value) {
  hashmap(ranks, c(c(1:10), jack_value, queen_value, king_value))
}

# Function to get the value of the card.
card_value <- function(card, rv_map) {
  rank <- unlist(strsplit(card, " "))[1] # "A H" -> "A"
  rv_map[[rank]]
}

rv_map <- create_rank_value_map(5, 5, 5)
card_value("10 H", rv_map)
```

```{r,eval=TRUE, echo=TRUE, include=TRUE}
# Calculates the key card (perhaps the last card in the deck) which is not followed by enough cards to get to another one.
# Given an initital deck, a rank value map, and the initial number from 1-10.
calc_key_card <- function(deck, rv_map, start_idx) {
  curr_card <- deck[start_idx]
  index <- start_idx
  
  while(index + card_value(curr_card, rv_map) <= 52) {
    index <- index + card_value(curr_card, rv_map)
    curr_card <- deck[index]
  }
  return(curr_card)
}

deck <- create_shuffled_deck()
rv_map <- create_rank_value_map(5, 5, 5)

calc_key_card(deck, rv_map, 1)
calc_key_card(deck, rv_map, 5)
```

```{r}
#one dimension optimization of mean average card value
fx <- seq(1, 10, 1)
fy <- 1-((fx^2-1)/fx^2)^52
plot(fx, fy)
#from the plot we see the maximum is achieved on the interval (1,4)

success_function_standard_deck <- function(x) {
  1-((x^2-1)/x^2)^52
}

optim_average_card_val = optimize(success_function_standard_deck, lower=1, upper = 10, maximum = TRUE)$maximum
optim_average_card_val

## its unrealistic to reduce all cards values close to 1, thus, we set the lower bound of the optimization to be the card average when face cards are counted as value 1

optim_average_realistic_card_val = optimize(success_function_standard_deck, lower=4.46, upper = 10, maximum = TRUE)$maximum
optim_average_realistic_card_val
```

```{r}
#one dimension optimization of deck size
default_card_mean_val = 5.384 #mean card value with face card values = 5
fx <- seq(0, 100, 4)
fy <- 1-((default_card_mean_val^2-1)/default_card_mean_val^2)^fx
plot(fx, fy)

success_function_default_val_mean <- function(N) {
  x=default_card_mean_val
  1-((x^2-1)/x^2)^N
}

optimize(success_function_default_val_mean, lower = 0, upper = 100, maximum=TRUE)
```

```{r}
#two dimensional optimization for both card mean average value and sample size

success_function <- function(input) {
  1-((input[1]^2-1)/input[1]^2)^input[2]
}

optim(c(4.46,10), success_function, method = "SANN")
```

http://www.ams.org/publicoutreach/feature-column/fcarc-mulcahy6
